import sharppy
import sharppy.sharptab.profile as profile
import sharppy.sharptab.interp as interp
import sharppy.sharptab.winds as winds
import sharppy.sharptab.utils as utils
import sharppy.sharptab.params as params
import sharppy.sharptab.thermo as thermo
import netCDF4 as nc
import numpy as np
import datetime as dt
import glob
import pandas as pd


#Functions to take reanalysis data at a single time step over some spatial domain, and calculate TS parameters


def get_dp(ta,hur):
	#Dew point approximation found at https://gist.github.com/sourceperl/45587ea99ff123745428
	#Same as "Magnus formula" https://en.wikipedia.org/wiki/Dew_point
	a = 17.27
	b = 237.7
	alpha = ((a * ta) / (b + ta)) + np.log(hur/100.0)
	return (b*alpha) / (a - alpha)

def get_point(point,lon,lat,ta,dp,hgt,ua,va,uas,vas,model):
	# Return 1d arrays for all variables, at a given spatial point (now a function of p-level only)
	if model == "barra":
		lon_ind = np.argmin(abs(lon-point[0]))
		lat_ind = np.argmin(abs(lat-point[1]))
		ta = np.squeeze(ta[:,lat_ind,lon_ind])
		dp = np.squeeze(dp[:,lat_ind,lon_ind])
		hgt = np.squeeze(hgt[:,lat_ind,lon_ind])
		ua = np.squeeze(ua[:,lat_ind,lon_ind])
		va = np.squeeze(va[:,lat_ind,lon_ind])
		uas = np.squeeze(uas[lat_ind,lon_ind])
		vas = np.squeeze(vas[lat_ind,lon_ind])
	elif model == "erai":
		lon_ind = np.argmin(abs(lon-point[0]))
		lat_ind = np.argmin(abs(lat-point[1]))
		ta = np.squeeze(ta[:,:,lat_ind,lon_ind])
		dp = np.squeeze(dp[:,:,lat_ind,lon_ind])
		hgt = np.squeeze(hgt[:,:,lat_ind,lon_ind])
		ua = np.squeeze(ua[:,:,lat_ind,lon_ind])
		va = np.squeeze(va[:,:,lat_ind,lon_ind])
		uas = np.squeeze(uas[:,lat_ind,lon_ind])
		vas = np.squeeze(vas[:,lat_ind,lon_ind])
	return [ta,dp,hgt,ua,va,uas,vas]

def calc_param(ta,dp,hgt,p,ua,va,uas,vas,lon,lat,param,model):
	#Loop over lat/lon points in domain and calculate: 1) profile 2) parcel (if create_parcel is set) 3) parameter
	#NOTE the choice of parameter may affect both steps 2) and 3)
	param = np.array(param)
	values = np.empty((len(lat)*len(lon),len(param)))
	values_lat = []
	values_lon = []
	cnt = 0
	for x in lon:
		print(x)
		for y in lat:
			#Restrict to a single spatial point
			point = [x,y]   
			ta_p,dp_p,hgt_p,ua_p,va_p,uas_p,vas_p = get_point(point,lon,lat,ta,dp,hgt,ua,va,uas,vas,model)
			#Convert u and v to kts for use in profile
			ua_p_kts = utils.MS2KTS(ua_p)
			va_p_kts = utils.MS2KTS(va_p)
			#Create profile
			prof = profile.create_profile(pres=p, hght=hgt_p, tmpc=ta_p, \
					dwpc=dp_p, u=ua_p_kts, v=va_p_kts)
			#Create most unstable parcel
			mu_parcel = params.parcelx(prof, flag=3)
			if "mu_cape" in param:
			#CAPE for most unstable parcel
				values[cnt,param=="mu_cape"] = mu_parcel.bplus
			if "s06" in param:
			#Wind shear 10 m (sfc) to 6 km
				ua_0km = uas_p
				ua_6km = np.interp(6000,hgt_p,ua_p)
				va_0km = vas_p
				va_6km = np.interp(6000,hgt_p,va_p)
				shear = np.sqrt(np.square(ua_6km-ua_0km)+np.square(va_6km-va_0km))
				values[cnt,param=="s06"] = shear
			if "mu_cin" in param:
			#CIN for most unstable parcel
				values[cnt,param=="mu_cin"] = -1*mu_parcel.bminus				
			if "hel03" in param:
			#Combined (+ve and -ve) rel. helicity from 0-3 km
				values[cnt,param=="hel03"] = winds.helicity(prof,0,3000)[0]
			if "hel06" in param:
			#Combined (+ve and -ve) rel. helicity from 0-6 km
				values[cnt,param=="hel06"] = winds.helicity(prof,0,6000)[0]
			if "ship" in param:
			#Significant hail parameter
				values[cnt,param=="ship"] = params.ship(prof,mupcl=mu_parcel)
			if "lhp" in param:
			#Large Hail Paramerer; NOTE requires convective profile (costly).
				conf_prof = profile.create_profile(profile="convective",pres=p, hght=hgt_p, tmpc=ta_p, \
                                        dwpc=dp_p, u=ua_p_kts, v=va_p_kts)
				values[cnt,param=="lhp"] = params.lhp(prof)
			if "hgz_depth" in param:
			#Hail growzth zone (in hPa)
				values[cnt,param=="hgz_depth"] = abs(params.hgz(prof)[1] - params.hgz(prof)[0])
			if "dcp" in param:
			#Derecho Composite Parameter ~ cold pool driven wind events
				values[cnt,param=="dcp"] = params.dcp(prof)
			if "mburst" in param:
			#Microburst composite index
				values[cnt,param=="mburst"] = params.mburst(prof)
			if "mmp" in param:
			#Mesoscale Convective System Maintanance Probability
				values[cnt,param=="mmp"] = params.mmp(prof,mupcl=mu_parcel)

			values_lat.append(y)
			values_lon.append(x)
			cnt = cnt+1
	df = pd.DataFrame(values,columns=param)
	df["lat"] = values_lat
	df["lon"] = values_lon
	return df	


def calc_param_mf(times,ta,dp,hur,hgt,p,ua,va,uas,vas,lon,lat,lon_used,lat_used,param,model,loc_id):

	#Same as calc_param except from inputs generated by read_*model*_mf()
	#Variables are now of the form [time, pressure, points]
	#Lat/lon are of length = number of points

	param = np.array(param)
	values = np.empty((len(lon)*len(times),len(param)))
	values_lat = []
	values_lon = []
	values_lon_used = []
	values_lat_used = []
	values_loc_id = []
	values_year = []; values_month = []; values_day = []; values_hour = []; values_minute = []
	cnt = 0
	for point in np.arange(0,len(lon)):
		print(lon[point],lat[point])
		for t in np.arange(len(times)):
			print(times[t])
	
			hgt_p = hgt[t,:,point]; ta_p = ta[t,:,point]; dp_p = dp[t,:,point];
			hur_p = hur[t,:,point];	ua_p = ua[t,:,point]; va_p = va[t,:,point]; 
			uas_p = uas[t,point]; vas_p = vas[t,point]; p_p = p[t,:,point]

			#Convert u and v to kts for use in profile
			ua_p_kts = utils.MS2KTS(ua_p)
			va_p_kts = utils.MS2KTS(va_p)
			#Create profile
			prof = profile.create_profile(pres=p_p, hght=hgt_p, tmpc=ta_p, \
					dwpc=dp_p, u=ua_p_kts, v=va_p_kts)
			#Create most unstable parcel
			mu_parcel = params.parcelx(prof, flag=3)
			if "relhum850-500" in param:
				values[cnt,param=="relhum850-500"] = \
					np.mean(hur_p[(p_p<=851) & (p_p>=499)])
			if "mu_cape" in param:
			#CAPE for most unstable parcel
				values[cnt,param=="mu_cape"] = mu_parcel.bplus
			if "s06" in param:
			#Wind shear 10 m (sfc) to 6 km
				ua_0km = uas_p
				ua_6km = np.interp(6000,hgt_p,ua_p)
				va_0km = vas_p
				va_6km = np.interp(6000,hgt_p,va_p)
				shear = np.sqrt(np.square(ua_6km-ua_0km)+np.square(va_6km-va_0km))
				values[cnt,param=="s06"] = shear
			if "mu_cin" in param:
			#CIN for most unstable parcel
				values[cnt,param=="mu_cin"] = -1*mu_parcel.bminus				
			if "hel03" in param:
			#Combined (+ve and -ve) rel. helicity from 0-3 km
				values[cnt,param=="hel03"] = winds.helicity(prof,0,3000)[0]
			if "hel06" in param:
			#Combined (+ve and -ve) rel. helicity from 0-6 km
				values[cnt,param=="hel06"] = winds.helicity(prof,0,6000)[0]
			if "ship" in param:
			#Significant hail parameter
				values[cnt,param=="ship"] = params.ship(prof,mupcl=mu_parcel)
			if "lhp" in param:
			#Large Hail Paramerer; NOTE requires convective profile (costly).
				conf_prof = profile.create_profile(profile="convective",pres=p_p, hght=hgt_p, tmpc=ta_p, \
					dwpc=dp_p, u=ua_p_kts, v=va_p_kts)
				values[cnt,param=="lhp"] = params.lhp(prof)
			if "hgz_depth" in param:
			#Hail growzth zone (in hPa)
				values[cnt,param=="hgz_depth"] = abs(params.hgz(prof)[1] - params.hgz(prof)[0])
			if "dcp" in param:
			#Derecho Composite Parameter ~ cold pool driven wind events
				values[cnt,param=="dcp"] = params.dcp(prof)
			if "mburst" in param:
			#Microburst composite index
				values[cnt,param=="mburst"] = params.mburst(prof)
			if "mmp" in param:
			#Mesoscale Convective System Maintanance Probability
				values[cnt,param=="mmp"] = params.mmp(prof,mupcl=mu_parcel)

			values_lat.append(lat[point])
			values_lon.append(lon[point])
			values_lat_used.append(lat_used[point])
			values_lon_used.append(lon_used[point])
			values_loc_id.append(loc_id[point])
			values_year.append(times[t].year)
			values_month.append(times[t].month)
			values_day.append(times[t].day)
			values_hour.append(times[t].hour)
			values_minute.append(times[t].minute)
			cnt = cnt+1

	df = pd.DataFrame(values,columns=param)
	df["lat"] = values_lat
	df["lon"] = values_lon
	df["lon_used"] = values_lon_used
	df["lat_used"] = values_lat_used
	df["loc_id"] = values_loc_id
	df["year"] = values_year
	df["month"] = values_month
	df["day"] = values_day
	df["hour"] = values_hour
	df["minute"] = values_minute
	return df	
